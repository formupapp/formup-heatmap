<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FormUp Half-Court Heatmap</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:#0b0b0c;color:#e8e8ea}
    .wrap{position:relative;height:100%;display:flex;align-items:center;justify-content:center;padding:12px;box-sizing:border-box}
    .card{position:relative;width:min(980px,96vw);aspect-ratio:9/8;background:#111215;border:1px solid #26272b;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
    .hud{position:absolute;inset:12px 12px auto auto;display:flex;gap:8px;align-items:center}
    .badge{padding:6px 10px;border-radius:999px;background:#1b1c21;border:1px solid #2d2f36;font-size:12px;opacity:.95}
    .legend{position:absolute;left:12px;bottom:12px;display:flex;gap:6px;align-items:center;padding:8px 10px;background:#121319cc;border:1px solid #2a2c33;border-radius:12px;backdrop-filter:blur(4px)}
    .legend-bar{width:180px;height:10px;border-radius:999px;background:linear-gradient(90deg,#440154,#472878,#3e4989,#2f6c8e,#22a884,#7ad151,#fde725)}
    svg{width:100%;height:100%;display:block}
    .dot{fill:#e5e7eb;fill-opacity:.85;stroke:#000;stroke-width:.75}
    .make{fill:#22c55e}.miss{fill:#ef4444}
    .court-line{stroke:#e7e7e7;stroke-opacity:.9;stroke-width:2;fill:none}
    .notice{position:absolute;left:12px;top:12px;font-size:12px;opacity:.7}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <!-- defs (blur filter) -->
      <svg style="position:absolute;width:0;height:0" aria-hidden="true" focusable="false">
        <defs>
          <filter id="smooth-heat" x="-10%" y="-10%" width="120%" height="120%">
            <!-- softer blur to avoid checkerboarding -->
            <feGaussianBlur stdDeviation="3" />
          </filter>
        </defs>
      </svg>

      <div class="hud" aria-live="polite">
        <span class="badge" id="modeBadge">Mode: –</span>
        <span class="badge" id="makesBadge">Makes: –</span>
        <span class="badge" id="missesBadge">Misses: –</span>
        <span class="badge" id="fgBadge">FG%: –</span>
      </div>

      <div class="legend" id="legend" hidden>
        <div class="legend-bar" aria-hidden="true"></div>
        <small id="legendLabel" style="opacity:.85">Cool → Hot</small>
      </div>

      <svg id="viz" viewBox="0 0 1000 888" preserveAspectRatio="xMidYMid meet" aria-label="Half-court shot chart"></svg>

      <div class="notice" id="notice"></div>
    </div>
  </div>

  <script>
    // ---------- helpers ----------
    const qs = new URLSearchParams(location.search);
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const lerp  = (a,b,t) => a + (b-a)*t;
    const byId  = id => document.getElementById(id);

    // Viridis LUT (compact)
    const VIRIDIS = [
      [68,1,84],[71,44,122],[59,81,139],[44,113,142],[33,144,141],
      [39,173,129],[92,200,99],[170,220,50],[253,231,37]
    ];
    function viridis(t){
      t = clamp(t,0,1)*(VIRIDIS.length-1);
      const i = Math.floor(t), f = t-i;
      const a = VIRIDIS[i], b = VIRIDIS[Math.min(i+1,VIRIDIS.length-1)];
      const r = Math.round(lerp(a[0],b[0],f));
      const g = Math.round(lerp(a[1],b[1],f));
      const bl= Math.round(lerp(a[2],b[2],f));
      return `rgb(${r},${g},${bl})`;
    }

    // Parse shots from ?s=x,y,m;... (x,y in 0–100; m=1 make, 0 miss)
    function parseShots() {
      const raw = (qs.get('s') || '').trim();
      if (!raw) return [];
      const parts = raw.split(';').map(p => p.trim()).filter(Boolean).slice(0, 1500);
      const shots = [];
      for (const p of parts) {
        const [x,y,m] = p.split(',').map(Number);
        if (Number.isFinite(x) && Number.isFinite(y)) shots.push({ x, y, m: (m|0) });
      }
      return shots;
    }

    // Optional custom bins: ?bins=30x26
    function parseBins() {
      const b = (qs.get('bins')||'').toLowerCase();
      const m = b.match(/^(\d+)[x×](\d+)$/);
      if (!m) return {bx:30, by:26}; // smooth default
      return {bx: Math.max(8, +m[1]), by: Math.max(8, +m[2])};
    }

    // % coords → viewBox px
    function mapXY(xp, yp) {
      return { X: clamp(xp,0,100)*10, Y: 888 - clamp(yp,0,100)*8.88 };
    }

    // -------- court (clean, proven layout) --------
    function el(n,a={}){const e=document.createElementNS('http://www.w3.org/2000/svg',n);for(const k in a)e.setAttribute(k,a[k]);if(!a.class&&(n==='path'||n==='line'||n==='circle'||n==='rect'))e.setAttribute('class','court-line');return e;}
    function line(x1,y1,x2,y2,a={}){return el('line',{x1,y1,x2,y2,...a});}
    function rect(x,y,w,h,a={}){return el('rect',{x,y,width:w,height:h,fill:'none',...a});}
    function circle(cx,cy,r,a={}){return el('circle',{cx,cy,r,...a});}
    function arc(cx,cy,r,s,e,a={}){const sx=cx+r*Math.cos(s),sy=cy+r*Math.sin(s),ex=cx+r*Math.cos(e),ey=cy+r*Math.sin(e),d=`M ${sx} ${sy} A ${r} ${r} 0 0 1 ${ex} ${ey}`;return el('path',{d,...a});}

    function drawCourt(svg){
      const g = el('g',{id:'court'});
      // edges
      g.appendChild(line(0,888,1000,888));
      g.appendChild(line(0,0,0,888));
      g.appendChild(line(1000,0,1000,888));
      // key & FT arc (these looked correct in your earlier version)
      g.appendChild(rect(350,698,300,190));                  // paint
      g.appendChild(arc(500,698,90,Math.PI,2*Math.PI));      // FT arc
      // hoop + restricted + backboard
      g.appendChild(circle(500,848,40));                     // restricted area
      g.appendChild(circle(500,848,9));                      // rim
      g.appendChild(line(455,842,545,842));                  // backboard
      svg.appendChild(g);
    }

    // --------------- heat aggregation ---------------
    function computeHeat(shots, binsX, binsY, mode){
      const grid = Array.from({length: binsY},()=>Array.from({length: binsX},()=>({n:0,m:0,v:0})));
      for (const s of shots){
        const bx = Math.min(binsX-1, Math.max(0, Math.floor(s.x/(100/binsX))));
        const by = Math.min(binsY-1, Math.max(0, Math.floor(s.y/(100/binsY))));
        const cell = grid[by][bx];
        cell.n++; cell.m += s.m?1:0;
      }
      let max=0;
      for (const row of grid) for (const cell of row){
        cell.v = (mode==='fg') ? (cell.n ? (cell.m/cell.n) : 0) : cell.n;
        if (cell.v > max) max = cell.v;
      }
      return {grid,max};
    }

    function drawHeat(svg, shots, mode, binsX, binsY){
      const {grid,max} = computeHeat(shots,binsX,binsY,mode);
      const w=1000/binsX, h=888/binsY;
      const g=el('g',{id:'heat', filter:'url(#smooth-heat)'});
      for (let by=0; by<binsY; by++){
        for (let bx=0; bx<binsX; bx++){
          const c=grid[by][bx];

          // *** KEY FIXES ***
          // 1) Density: don't paint empty cells (kills checkerboard)
          // 2) FG%: hide very tiny samples, fade in with N
          if (mode !== 'fg' && c.n === 0) continue;

          const t = max>0 ? (c.v/max) : 0;
          let alpha = 0.55;
          if (mode==='fg'){
            if (c.n < 3) continue;
            alpha = Math.min(c.n/12, 0.75);
          }
          if (t <= 0) continue;

          g.appendChild(rect(bx*w, 888-(by+1)*h, w, h, {
            fill: viridis(t),
            'fill-opacity': alpha,
            stroke: 'none'
          }));
        }
      }
      svg.appendChild(g);
    }

    function drawDots(svg, shots){
      if ((qs.get('dots')||'0') !== '1') return;
      const g = el('g',{id:'dots'});
      for (const s of shots){
        const {X,Y}=mapXY(s.x,s.y);
        g.appendChild(circle(X,Y,5,{class:`dot ${s.m?'make':'miss'}`, 'fill-opacity':0.6}));
      }
      svg.appendChild(g);
    }

    // --------------- build ---------------
    function main(){
      const svg = byId('viz');
      const shots = parseShots();
      const {bx,by} = parseBins();
      const mode = (qs.get('mode')||'heat').toLowerCase(); // 'heat' | 'fg' | 'dots'
      const showLegend = (qs.get('legend')||'1') !== '0';

      drawCourt(svg);

      if (mode === 'dots') {
        drawHeat(svg, shots, 'density', bx, by);
        drawDots(svg, shots);
      } else {
        drawHeat(svg, shots, mode==='fg'?'fg':'density', bx, by);
        drawDots(svg, shots);
      }

      const makes = shots.filter(s=>s.m).length, misses = shots.length - makes;
      const fg = shots.length ? Math.round(makes/shots.length*100) : 0;

      byId('modeBadge').textContent   = `Mode: ${mode==='fg'?'Zone FG%': mode==='heat'?'Density':'Shot Dots'}`;
      byId('makesBadge').textContent  = `Makes: ${makes}`;
      byId('missesBadge').textContent = `Misses: ${misses}`;
      byId('fgBadge').textContent     = `FG%: ${fg}`;

      byId('legendLabel').textContent = mode==='fg'
        ? 'Cool → Hot (lower → higher FG%)'
        : 'Cool → Hot (lower → higher attempt density)';
      byId('legend').hidden = !showLegend;

      byId('notice').innerHTML =
        'Params: <b>s</b>=x,y,m;… (0–100), <b>mode</b>=heat|fg|dots, <b>legend</b>=1|0, <b>dots</b>=1|0, <b>bins</b>=WxH';
    }

    main();
  </script>
</body>
</html>
