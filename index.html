<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FormUp Half-Court Heatmap</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:#0b0b0c;color:#e8e8ea}
    .wrap{position:relative;height:100%;display:flex;align-items:center;justify-content:center;padding:12px;box-sizing:border-box}
    .card{position:relative;width:min(980px,96vw);aspect-ratio:9/8;background:#111215;border:1px solid #26272b;border-radius:18px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden}
    .hud{position:absolute;inset:12px 12px auto auto;display:flex;gap:8px;align-items:center}
    .badge{padding:6px 10px;border-radius:999px;background:#1b1c21;border:1px solid #2d2f36;font-size:12px;opacity:.95}
    .legend{position:absolute;left:12px;bottom:12px;display:flex;gap:6px;align-items:center;padding:8px 10px;background:#121319cc;border:1px solid #2a2c33;border-radius:12px;backdrop-filter:blur(4px)}
    .legend-bar{width:180px;height:10px;background:linear-gradient(90deg,#1d4ed8,#22d3ee,#22c55e,#fde047,#f59e0b,#ef4444);border-radius:999px}
    svg{width:100%;height:100%;display:block}
    .dot{fill:#e5e7eb;fill-opacity:.85;stroke:#000;stroke-width:.75}
    .make{fill:#22c55e}.miss{fill:#ef4444}
    .court-line{stroke:#e7e7e7;stroke-opacity:.85;stroke-width:2;fill:none}
    .notice{position:absolute;left:12px;top:12px;font-size:12px;opacity:.7}
    .lock{position:absolute;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.38);backdrop-filter:blur(6px)}
    .lock .panel{background:#0f1116;border:1px solid #2a2d35;padding:14px 16px;border-radius:14px;text-align:center}
    .lock .cta{display:inline-block;margin-top:8px;padding:8px 12px;border-radius:999px;background:#2563eb;color:#fff;font-weight:700;text-decoration:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <!-- hidden defs (filters) -->
      <svg style="position:absolute;width:0;height:0" aria-hidden="true" focusable="false">
        <defs>
          <filter id="smooth-heat" x="-10%" y="-10%" width="120%" height="120%">
            <feGaussianBlur stdDeviation="4" />
          </filter>
        </defs>
      </svg>

      <div class="hud" aria-live="polite">
        <span class="badge" id="modeBadge">Mode: –</span>
        <span class="badge" id="makesBadge">Makes: –</span>
        <span class="badge" id="missesBadge">Misses: –</span>
        <span class="badge" id="fgBadge">FG%: –</span>
      </div>

      <div class="legend" id="legend" hidden>
        <div class="legend-bar" aria-hidden="true"></div>
        <small style="opacity:.85">Cool → Hot (lower → higher density / FG%)</small>
      </div>

      <svg id="viz" viewBox="0 0 1000 888" preserveAspectRatio="xMidYMid meet" aria-label="Half-court shot chart"></svg>

      <div class="lock" id="lock" hidden>
        <div class="panel">
          <div style="font-weight:800;margin-bottom:4px">Heat Map (Premium)</div>
          <div style="opacity:.8">Unlock hi-res zones, FG% overlay, and filters.</div>
          <a class="cta" href="#" onclick="window.parent?.postMessage({type:'formup:upgrade'},'*');return false;">Upgrade</a>
        </div>
      </div>

      <div class="notice" id="notice"></div>
    </div>
  </div>

  <script>
    // ---------- helpers ----------
    const qs = new URLSearchParams(location.search);
    const clamp = (n, lo, hi) => Math.max(lo, Math.min(hi, n));
    const lerp  = (a,b,t) => a + (b-a)*t;

    // Parse shots from ?s=x,y,m;... (x,y in 0–100; m=1 make, 0 miss)
    function parseShots() {
      const raw = (qs.get('s') || '').trim();
      if (!raw) return [];
      // guard against huge query strings (keeps render snappy)
      const parts = raw.split(';').map(p => p.trim()).filter(Boolean).slice(0, 800);
      const shots = [];
      for (const p of parts) {
        const [x,y,m] = p.split(',').map(Number);
        if (Number.isFinite(x) && Number.isFinite(y)) {
          shots.push({ x, y, m: (m|0) });
        }
      }
      return shots;
    }

    // Optional custom bins: ?bins=30x26
    function parseBins() {
      const b = (qs.get('bins')||'').toLowerCase();
      const m = b.match(/^(\d+)[x×](\d+)$/);
      if (!m) return {bx:30, by:26}; // smooth default
      return {bx: Math.max(8, +m[1]), by: Math.max(8, +m[2])};
    }

    // % coords to viewBox coords
    function mapXY(xp, yp) {
      return { X: clamp(xp,0,100)*10, Y: 888 - clamp(yp,0,100)*8.88 };
    }

    // ----- court -----
    function drawCourt(svg){
      const g = el('g',{id:'court'});
      // baseline + sidelines
      g.appendChild(line(0,888,1000,888));
      g.appendChild(line(0,0,0,888));
      g.appendChild(line(1000,0,1000,888));
      // paint (key)
      g.appendChild(rect(350,888-190,300,190));
      // free-throw arc
      g.appendChild(arc(500,888-190,90,Math.PI,2*Math.PI));
      // rim + restricted + backboard
      g.appendChild(circle(500,888-40,40));
      g.appendChild(circle(500,888-40,9));
      g.appendChild(line(455,888-46,545,888-46));
      svg.appendChild(g);
    }

    // heat aggregation
    function computeHeat(shots, binsX, binsY, mode){
      const grid = Array.from({length: binsY},()=>Array.from({length: binsX},()=>({n:0,m:0,v:0})));
      for (const s of shots){
        const bx = Math.min(binsX-1, Math.max(0, Math.floor(s.x/(100/binsX))));
        const by = Math.min(binsY-1, Math.max(0, Math.floor(s.y/(100/binsY))));
        const cell = grid[by][bx];
        cell.n++; cell.m += s.m?1:0;
      }
      let max=0;
      for (const row of grid) for (const cell of row){
        cell.v = (mode==='fg') ? (cell.n ? (cell.m/cell.n) : 0) : cell.n;
        if (cell.v > max) max = cell.v;
      }
      return {grid,max};
    }

    function colorFor(t){
      // blue → cyan → green → yellow → orange → red
      const stops=[[29,78,216],[34,211,238],[34,197,94],[253,224,71],[245,158,11],[239,68,68]];
      t = clamp(t,0,1);
      const seg=Math.min(stops.length-2,Math.floor(t*(stops.length-1)));
      const tt=t*(stops.length-1)-seg, a=stops[seg], b=stops[seg+1];
      const r=Math.round(lerp(a[0],b[0],tt)), g=Math.round(lerp(a[1],b[1],tt)), bl=Math.round(lerp(a[2],b[2],tt));
      return `rgb(${r},${g},${bl})`;
    }

    function drawHeat(svg, shots, mode, binsX, binsY){
      const {grid,max} = computeHeat(shots,binsX,binsY,mode);
      const w=1000/binsX, h=888/binsY;
      const g=el('g',{id:'heat', filter:'url(#smooth-heat)'});
      for (let by=0; by<binsY; by++){
        for (let bx=0; bx<binsX; bx++){
          const c=grid[by][bx];
          const t = max>0 ? (c.v/max) : 0;
          g.appendChild(rect(bx*w, 888-(by+1)*h, w, h, { fill: colorFor(t), 'fill-opacity': t===0?0:0.6, stroke:'none' }));
        }
      }
      svg.appendChild(g);
    }

    function drawDots(svg, shots){
      const g = el('g',{id:'dots'});
      for (const s of shots){
        const {X,Y}=mapXY(s.x,s.y);
        g.appendChild(circle(X,Y,7,{class:`dot ${s.m?'make':'miss'}`}));
      }
      svg.appendChild(g);
    }

    // ----- build -----
    function main(){
      const svg = document.getElementById('viz');
      const shots = parseShots();
      const {bx,by} = parseBins();
      const mode = (qs.get('mode')||'heat').toLowerCase(); // 'heat' | 'fg' | 'dots'
      const showLegend = (qs.get('legend')||'1') !== '0';

      // lock disabled for testing; switch to qs.get('lock') === '1' when you monetize
      const locked = false;

      drawCourt(svg);

      if (mode === 'dots') drawDots(svg, shots);
      else drawHeat(svg, shots, mode==='fg'?'fg':'density', bx, by);

      const makes = shots.filter(s=>s.m).length, misses = shots.length - makes;
      const fg = shots.length ? Math.round(makes/shots.length*100) : 0;

      byId('modeBadge').textContent = `Mode: ${mode==='fg'?'Zone FG%': mode==='heat'?'Density':'Shot Dots'}`;
      byId('makesBadge').textContent = `Makes: ${makes}`;
      byId('missesBadge').textContent = `Misses: ${misses}`;
      byId('fgBadge').textContent = `FG%: ${fg}`;

      byId('legend').hidden = (mode==='dots') || !showLegend;
      byId('lock').hidden = !locked;

      byId('notice').innerHTML =
        'Params: <b>s</b>=x,y,m;… (<i>0–100%</i>), <b>mode</b>=heat|fg|dots, <b>legend</b>=1|0, <b>lock</b>=1|0, <b>bins</b>=WxH';
    }

    // tiny SVG helpers
    const byId = id => document.getElementById(id);
    function el(n,a={}){const e=document.createElementNS('http://www.w3.org/2000/svg',n);for(const k in a)e.setAttribute(k,a[k]);if(!a.class&&(n==='path'||n==='line'||n==='circle'||n==='rect'))e.setAttribute('class','court-line');return e;}
    function line(x1,y1,x2,y2,a={}){return el('line',{x1,y1,x2,y2,...a});}
    function rect(x,y,w,h,a={}){return el('rect',{x,y,width:w,height:h,fill:'none',...a});}
    function circle(cx,cy,r,a={}){return el('circle',{cx,cy,r,...a});}
    function arc(cx,cy,r,s,e,a={}){const sx=cx+r*Math.cos(s),sy=cy+r*Math.sin(s),ex=cx+r*Math.cos(e),ey=cy+r*Math.sin(e),d=`M ${sx} ${sy} A ${r} ${r} 0 0 1 ${ex} ${ey}`;return el('path',{d,...a});}

    main();
  </script>
</body>
</html>
